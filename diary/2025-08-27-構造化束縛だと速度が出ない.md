## 構造化束縛が最適化を妨げる話
### 2025-08-27

```c++
#include <boost/uuid.hpp>

#include <saitekikuukan.hpp>
#include <print>

int main() {
    using namespace kk;

    struct enemy {
        int max_hp, hp, max_mp, mp, x, y;
    };

    constexpr size_t Size = 1024 * 10;

    static_buffer<generator::iota, eventsystem::dummy, Size, int, int, int, int, int, int> enemies_of_array;
    auto &[max_hp, hp, max_mp, mp, x, y] = enemies_of_array.entries;
    auto& elem_x = enemies_of_array.get<4>();
    auto& elem_y = enemies_of_array.get<5>();
    auto [max_hp_p, hp_p, max_mp_p, mp_p, x_p, y_p] = std::make_tuple(reinterpret_cast<int*>(&max_hp), reinterpret_cast<int*>(&hp), reinterpret_cast<int*>(&max_mp), reinterpret_cast<int*>(&mp), reinterpret_cast<int*>(&x), reinterpret_cast<int*>(&y));


    std::array<enemy, Size> array_of_enemies{};

    {
        auto start = std::chrono::high_resolution_clock::now();
        for (int i = 0; i < Size; i++) {
            for (size_t j = 0; j < Size; j++) {
                x[j] += i;
                y[j] += Size - i;
            }
        }
        auto end = std::chrono::high_resolution_clock::now();
        std::println("{}", std::chrono::duration_cast<std::chrono::microseconds>(end - start));
    }

    {
        auto start = std::chrono::high_resolution_clock::now();
        for (int i = 0; i < Size; i++) {
            for (size_t j = 0; j < Size; j++) {
                elem_x[j] += i;
                elem_y[j] += Size - i;
            }
        }
        auto end = std::chrono::high_resolution_clock::now();
        std::println("{}", std::chrono::duration_cast<std::chrono::microseconds>(end - start));
    }

    {
        auto start = std::chrono::high_resolution_clock::now();
        for (int i = 0; i < Size; i++) {
            for (size_t j = 0; j < Size; j++) {
                x_p[j] += i;
                y_p[j] += Size - i;
            }
        }
        auto end = std::chrono::high_resolution_clock::now();
        std::println("{}", std::chrono::duration_cast<std::chrono::microseconds>(end - start));
    }

    {
        auto start = std::chrono::high_resolution_clock::now();
        for (int i = 0; i < Size; i++) {
            for (size_t j = 0; j < Size; j++) {
                array_of_enemies[j].x += i;
                array_of_enemies[j].y += Size - i;
            }
        }
        auto end = std::chrono::high_resolution_clock::now();
        std::println("{}", std::chrono::duration_cast<std::chrono::microseconds>(end - start));
    }
    return 0;
}
```
を実行すると
```
49139µs
37866µs
37870µs
68635µs
```
となり構造化束縛をした時の変数を使うと最適化が阻害されている、
構造化束縛はそのままgetを順にするのではなく一回`auto& __tmp = enemies_of_array.entries;`のように内部で対象の参照をとっているかららしいが、
結構納得がいかない最適化でそこも潰して欲しい、しかも標準ライブラリではなく言語仕様なので手の加えようがない


コンパイラをGCCに変えたら最適化で潰れた☺️
```
38116µs
38014µs
38025µs
69462µs
```
