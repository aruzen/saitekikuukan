## static_bufferとdynamic_buffer
### 2025-09-10


iterator/const_iteratorの実装を`dynamic_buffer`と`static_buffer`どちらにも書いているが
とても助長なのでやめたいそこでiteratorを切り出し再利用することを考えた。
が、まずそもそも`dynamic_buffer`と`static_buffer`に実装を分ける必要があるのか気になったので
diffをとってみることにした、

```c++
--- dynamic.hpp	2025-09-11 00:16:12
+++ static.hpp	2025-09-10 23:57:28
@@ -1,23 +1,8 @@
-template<typename ...Types>
-struct dynamic_entries_type {
-    using tl = type_list<Types...>;
-    using vector = tl::template wrap<std::vector>;
-    using meta_id = vector::template wrap_meta_id<0>;
-    using result = meta_id::template apply<std::tuple>;
-};
+template<generator::is_generator IDGenerator = generator::iota, eventsystem::is_eventsystem EventSystem = eventsystem::dummy, size_t MaxSize = 16, typename ...Types>
+struct static_buffer {
+    using this_type = static_buffer<IDGenerator, EventSystem, MaxSize, Types...>;
 
-template<size_t Size, typename ...Types>
-struct static_entries_type {
-    using tl = type_list<Types...>;
-    using array = tl::template wrap_array<Size>;
-    using meta_id = array::template wrap_meta_id<0>;
-    using result = meta_id::template apply<std::tuple>;
-};
-
-template<generator::is_generator IDGenerator = generator::iota, eventsystem::is_eventsystem EventSystem = eventsystem::dummy, typename ...Types>
-struct dynamic_buffer {
-    using this_type = dynamic_buffer<IDGenerator, EventSystem, Types...>;
-
+    static constexpr size_t max_size = MaxSize;
     using id_type = typename IDGenerator::generate_type;
     using element_types = _meta::type_list<Types...>;
 
@@ -28,9 +13,10 @@
 private:
     [[no_unique_address]] IDGenerator m_generator;
     [[no_unique_address]] EventSystem m_eventsystem;
+    size_t m_end_index = 0;
 public:
-    std::vector<id_type> ids;
-    typename dynamic_entries_type<Types...>::result entries;
+    std::array<id_type, max_size> ids;
+    typename static_entries_type<max_size, Types...>::result entries;
 
 
     template<std::size_t N>
@@ -44,11 +30,11 @@
     }
 
     [[nodiscard]] std::size_t size() const {
-        return ids.size();
+        return m_end_index;
     }
 
     [[nodiscard]] bool empty() const {
-        return ids.empty();
+        return m_end_index == 0;
     }
 
     std::expected<size_t, error_code> index(id_type id) const {
@@ -91,35 +77,35 @@
 
     template<typename ...Args>
     std::expected<void, error_code> push_back(Args &&... args) {
+        if (max_size < m_end_index + 1)
+            return std::unexpected{error_code::buffer_over};
         std::optional<id_type> id = m_generator.next();
         if (not id)
             return std::unexpected{error_code::generate_id_failed};
-        ids.push_back(id.value());
+        ids[m_end_index] = id.value();
         [&]<std::size_t... Is>(std::index_sequence<Is...>) {
-            ((std::get<Is>(entries).push_back(std::forward<Types>(args))), ...);
+            ((std::get<Is>(entries)[m_end_index] = std::forward<Types>(args)), ...);
         }(std::make_index_sequence<sizeof...(Types)>{});
+        m_end_index++;
         return {};
     }
 
     void pop_back() {
-        ids.pop_back();
-        [&]<std::size_t... Is>(std::index_sequence<Is...>) {
-            ((std::get<Is>(entries).pop_back()), ...);
-        }(std::make_index_sequence<sizeof...(Types)>{});
+        if (0 < m_end_index)
+            m_end_index--;
     }
 
     void clear() {
-        ids.clear();
-        [&]<std::size_t... Is>(std::index_sequence<Is...>) {
-            ((std::get<Is>(entries).clear()), ...);
-        }(std::make_index_sequence<sizeof...(Types)>{});
+        m_end_index = 0;
     }
 
     std::expected<void, error_code> resize(size_t size) {
-        ids.resize(size);
-        [&]<std::size_t... Is>(std::index_sequence<Is...>) {
-            ((std::get<Is>(entries).resize(size)), ...);
-        }(std::make_index_sequence<sizeof...(Types)>{});
+        if (max_size < size) {
+            return std::unexpected{error_code::buffer_over};
+        } else {
+            this->m_end_index = size;
+            return {};
+        }
     }
 
     std::expected<void, error_code> erase(id_type id) {
@@ -142,7 +128,7 @@
     }
 
     iterator end() {
-        return iterator(this, size());
+        return iterator(this, this->m_end_index);
     }
 
     const_iterator begin() const {
@@ -150,7 +136,7 @@
     }
 
     const_iterator end() const {
-        return const_iterator(this, size());
+        return const_iterator(this, this->m_end_index);
     }
 
     const_iterator cbegin() const {
@@ -158,7 +144,7 @@
     }
 
     const_iterator cend() const {
-        return const_iterator(this, size());
+        return const_iterator(this, this->m_end_index);
     }
 
     struct entry {
```

案の定ほぼなかったので逆に`dynamic_buffer/static_buffer`をまとめ、
ストレージ戦略を切り分ける方針でいく、次の悩みは`size_t index(id_type)`関数でインデックスを線形探査しているがこれを0(1)に置き換えるかどうか悩んでいる。